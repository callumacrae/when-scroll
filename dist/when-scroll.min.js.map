{"version":3,"sources":["node_modules/lmn-gulp-tasks/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/fix-ev/index.js","when-scroll.min.js","src/parser.js","src/truth.js","src/util.js","src/when-scroll.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","curry","fn","ev","this","fix","window","event","target","srcElement","preventDefault","set","stopPropagation","key","val",2,"Parser","scrollPattern","pattern","patternToArray","patternOkay","_truths","el","nodeType","ELEMENT_NODE","undefined","push","Truth","multiple","util","some","truth","fired","isArray","reduce","acc","item","concat","split","word","Node","prototype","isTrue","scrollTop","every","./truth","./util",3,"type","distance","parseScrollDistance","_check","checks","parseInt","below","above","within","viewportOffset","getBoundingClientRect","top","windowHeight","innerHeight","document","documentElement","clientHeight","_lastFiredAt","Math","abs",4,"on","element","cb","addEventListener","attachEvent","each","arr","scope","initial","splice","curr","obj","Object","toString","fix-ev",5,"whenScroll","initialCheck","scrollHandler","handler","./parser"],"mappings":"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","file":"when-scroll.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\n/**\n * Expose `curry` and `fix`.\n */\n\nmodule.exports = curry;\ncurry.fix = fix;\n\n/**\n * Fix event helper.\n *\n * Usage:\n *\n *   el.on('click', fix(function (ev) {\n *     // ...\n *   }));\n *\n * @param {Function} fn\n * @return {Function}\n * @api public\n */\n\nfunction curry (fn) {\n  return function (ev) {\n    fn.call(this, fix(ev));\n  }\n}\n\n/**\n * Fix event.\n *\n * @param {Event|Undefined} ev\n * @return {Event}\n * @api public\n */\n\nfunction fix (ev) {\n  if (!ev) ev = window.event;\n  if (!ev.target) ev.target = event.srcElement;\n  if (!ev.preventDefault) ev.preventDefault = set('returnValue', false);\n  if (!ev.stopPropagation) ev.stopPropagation = set('cancelBubble', false);\n  return ev;\n}\n\n/**\n * What is `set`? Not a continuable, not a future, how do you call that?\n *\n * @param {String} key\n * @param {Object} value\n * @return {Function}\n * @api private\n */\n\nfunction set (key, val) {\n  return function () {\n    this[key] = val;\n  }\n}\n",null,"'use strict';\n\nvar util = require('./util');\nvar Truth = require('./truth');\n\nvar ELEMENT_NODE = window.Node ? Node.ELEMENT_NODE : 1;\n\n/**\n * The parser that powers when-scroll. Takes a string or array containing a\n * a string and element, and exposes a method which can be called to see\n * whether the pattern is true yet.\n *\n * @param {Array|string} scrollPattern The array or string to parse. Could be\n *     something like \"below 1000px\" or could be something more complicated.\n *     Could also have something like an element in, for examples like\n *     [\"within 100px of\", el].\n * @constructor\n */\nfunction Parser(scrollPattern) {\n\tthis.pattern = scrollPattern;\n\n\tscrollPattern = patternToArray(scrollPattern);\n\n\tif (!patternOkay(scrollPattern)) {\n\t\tthrow new Error('when-scroll error: invalid pattern');\n\t}\n\n\tthis._truths = [];\n\n\t// This splits the scroll pattern into multiple \"truths\", so \"every 100px\n\t// below 200px\" will turn into two truths, one \"every 100px\" and the other\n\t// \"below 200px\".\n\tfor (var i = 0; i < scrollPattern.length; i += 2) {\n\t\tvar el = scrollPattern[i + 2];\n\t\tif (!el || el.nodeType !== ELEMENT_NODE) {\n\t\t\tel = undefined;\n\t\t}\n\n\t\tthis._truths.push(new Truth(scrollPattern[i], scrollPattern[i + 1], el));\n\n\t\tif (el) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// If any of the Truths are multiple, the entire thing should be\n\t// The multiple property means the callback can be called multiple times\n\tthis.multiple = util.some(this._truths, function (truth) {\n\t\treturn truth.multiple;\n\t});\n\n\tthis.fired = false;\n}\n\n/**\n * Returns whether the scroll pattern is now true. Call this for example on\n * scroll.\n *\n * @param {number} scrollTop window.scrollY, probably.\n * @returns {boolean} True if scroll pattern is true.\n */\nParser.prototype.isTrue = function parserIsTrue(scrollTop) {\n\tif (this.fired && !this.multiple) {\n\t\treturn false;\n\t}\n\n\tvar isTrue = util.every(this._truths, function (truth) {\n\t\treturn truth.isTrue(scrollTop);\n\t});\n\n\tif (isTrue) {\n\t\t// YOU'RE FIRED\n\t\tthis.fired = true;\n\t}\n\n\treturn isTrue;\n};\n\nmodule.exports = Parser;\n\n/**\n * Turns the scroll pattern into an array. Basically removes words like \"and\"\n * and \"of\" and turns the entire thing into a flat array of single words and\n * elements.\n *\n * @param {Array|string} scrollPattern The scroll pattern to process.\n * @returns {Array} Processed scroll pattern. Like [\"below\", \"1000px\"].\n */\nfunction patternToArray(scrollPattern) {\n\tif (util.isArray(scrollPattern)) {\n\t\treturn util.reduce(scrollPattern, function (acc, item) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn acc.concat(patternToArray(item));\n\t\t\t}\n\n\t\t\tacc.push(item);\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\treturn util.reduce(scrollPattern.split(' '), function (acc, word) {\n\t\tif (word !== 'and' && word !== 'of') {\n\t\t\tacc.push(word);\n\t\t}\n\n\t\treturn acc;\n\t}, []);\n}\n\n/**\n * Tests whether a scroll pattern is valid.\n *\n * @param {Array} scrollPattern The scroll pattern after patternToArray work\n * @returns {boolean} True if valid. False if not.\n */\nfunction patternOkay(scrollPattern) {\n\tif (scrollPattern.length % 2 === 0) {\n\t\treturn true;\n\t}\n\n\treturn (scrollPattern[0] === 'within' && scrollPattern.length === 3);\n}\n","'use strict';\n\n// Polyfill for Node.ELEMENT_NODE\nvar ELEMENT_NODE = window.Node ? Node.ELEMENT_NODE : 1;\n\n/**\n * Handles a part of a scroll pattern. Similar to the parser, but handles only\n * part of the pattern, and contains the actual logic for whether it is true.\n *\n * @param {string} type Type of check: \"below\", \"above\", \"within\" or \"every\".\n * @param {string|number} distance An amount of pixels.\n * @param {HTMLElement} [el] An optional element for if the check needs one.\n * @constructor\n */\nfunction Truth(type, distance, el) {\n\tthis.type = type;\n\tthis.distance = parseScrollDistance(distance);\n\n\tif (el && el.nodeType === ELEMENT_NODE) {\n\t\tthis.el = el;\n\t}\n\n\tthis._check = checks[this.type];\n\n\tif (typeof this._check !== 'function') {\n\t\tthrow new Error(this.type + ' check not found');\n\t}\n\n\t// The multiple property means the callback can be called multiple times\n\tthis.multiple = this._check.multiple || false;\n}\n\n/**\n * Called by parser.isTrue(), executes the relevant check and returns whether\n * the Truth is true.\n *\n * @param {number} scrollTop window.scrollY, I guess.\n * @returns {boolean} True if true.\n */\nTruth.prototype.isTrue = function truthIsTrue(scrollTop) {\n\treturn this._check(scrollTop);\n};\n\nmodule.exports = Truth;\n\n// These checks are called by .isTrue().\nvar checks = {};\n\n// \"below 1000px\"\nchecks.below = function belowCheck(scrollTop) {\n\treturn this.distance <= scrollTop;\n};\n\n// \"above 1000px\"\nchecks.above = function aboveCheck(scrollTop) {\n\treturn this.distance >= scrollTop;\n};\n\n// [\"within 100px of\", element]\nchecks.within = function withinCheck() {\n\tvar viewportOffset = this.el.getBoundingClientRect().top;\n\tvar windowHeight = window.innerHeight || document.documentElement.clientHeight;\n\treturn viewportOffset - windowHeight < this.distance;\n};\n\n// \"every 200px\"\nchecks.every = function everyCheck(scrollTop) {\n\tif (!this._lastFiredAt) {\n\t\tthis._lastFiredAt = 0;\n\t}\n\n\tif (Math.abs(this._lastFiredAt - scrollTop) >= this.distance) {\n\t\tthis._lastFiredAt = scrollTop;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\nchecks.every.multiple = true;\n\n/**\n * Converts a string into a number of pixels. Currently only supports pixels.\n *\n * @todo: Support more than pixels!\n *\n * @param {string} distance The distance down the page in pixels.\n * @returns {number} The distance down the page in pixels.\n */\nfunction parseScrollDistance(distance) {\n\treturn parseInt(distance);\n}\n","'use strict';\n\nvar util = module.exports = {};\nvar fix = require('fix-ev');\n\nutil.on = function onEvent(event, element, cb) {\n\tif (element.addEventListener) {\n\t\telement.addEventListener(event, cb);\n\t} else if (element.attachEvent) {\n\t\telement.attachEvent('on' + event, fix(cb));\n\t}\n};\n\nutil.each = function arrayEach(arr, cb, scope) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tcb.call(scope, arr[i], i, arr);\n\t}\n};\n\nutil.reduce = function arrayReduce(arr, cb, initial) {\n\tif (typeof initial === 'undefined') {\n\t\tinitial = arr.splice(0, 1)[0];\n\t}\n\n\t// It would be silly to carry on calling it initial\n\tvar acc = initial;\n\n\tutil.each(arr, function (curr) {\n\t\tacc = cb(acc, curr);\n\t});\n\n\treturn acc;\n};\n\nutil.some = function (arr, cb) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (cb(arr[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nutil.every = function (arr, cb) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (!cb(arr[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nutil.isArray = function isArray(obj) {\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n};\n","'use strict';\n\nvar util = require('./util');\nvar Parser = require('./parser');\n\n/**\n * Initiate when-scroll.\n *\n * This function calls the parser, and sets up a scroll handler to check\n * whether the parser is true on scroll. If it is, will call the callback.\n *\n * @param {Array|string} scrollPattern The array or string to parse. See readme\n *     or {@see Parser}\n * @param {function} cb The callback to call when the pattern matches\n * @param {boolean} [initialCheck] If true, will check whether it's true on\n *     page load.\n */\nfunction whenScroll(scrollPattern, cb, initialCheck) {\n\tvar handler = new Parser(scrollPattern);\n\n\tutil.on('scroll', window, scrollHandler);\n\n\tif (initialCheck) {\n\t\tutil.on('DOMContentLoaded', document, scrollHandler);\n\t}\n\n\tfunction scrollHandler() {\n\t\tvar scrollTop = document.documentElement.scrollTop;\n\t\tif (handler.isTrue(scrollTop)) {\n\t\t\tcb(scrollTop);\n\t\t}\n\t}\n}\n\nwindow.whenScroll = module.exports = whenScroll;\n"],"sourceRoot":"/source/"}